<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>二叉树</title>
	<style>
		body{
			font:14px Helvetica,Arial,"Microsoft Yahei",sans-serif;
		}
	</style>
</head>
<body>
<canvas id="canvas" width="1000" height="750"></canvas>
<script>
	//二叉树	
	function BTree(list,parent){
		this.key=list[0];//值
		this.parent=parent||null;//父节点
		this.left=null;//左节点
		this.right=null;//右节点
		this.leftThread=false;//左线索，默认是节点 
		this.rightThread=false;//右线索
		this.level=parent?parent.level+1:0;//树的深度
		for(var i=1,len=list.length;i<len;i++){
			this.insert(list[i]);
		}
	}

	BTree.prototype={
		insert:function(key){//插入
			if(this.key>key){
				if(!this.left){
					return this.left=new BTree([key],this);
				} else {
					return this.left.insert(key);
				}
			} else {
				if(!this.right){
					return this.right=new BTree([key],this);
				} else {
					return this.right.insert(key);
				}
			}
		},
		delete:function(key){//删除
			if(this.key==key){
				if(this.left&&this.right){
					var node=this.right;
					while (node.left) {//找到最左的节点
						node=node.left;
					}
					if(this.key==node.parent.key){//没有左节点的情况，直接将右子树上移
						this.key=node.key;
						this.right=node.right;
					} else {//有左节点的情况
						this.key=node.key;
						if(node.right){//如果还存在右节点，将右节点上移
							node.right.parent=node.parent;
							node=node.right;
						} else {//直接将该节点清除
							node.parent.left=null;
						}
					}
				} else {
					var prop=this.parent.key>this.key?'left':'right';
					if(this.left) {//只有左子树
						this.left.parent=this.parent;
						this.parent[prop]=this.left;
					} else if(this.right){//只有右子树
						this.right.parent=this.parent;
						this.parent[prop]=this.right;
					} else {//叶子节点
						this.parent[prop]=null;
					}
				}
				return this;			
			} else if(this.key>key){
				return this.left?this.left.delete(key):null;
			} else {
				return this.right?this.right.delete(key):null;
			}

		},
		search:function(key){//搜索
			if(this.key==key){
				return this;
			} else if(this.key>key){
				return this.left?this.left.search(key):null;
			} else {
				return this.right?this.right.search(key):null;
			}
		},
		fTravelTree:function(callback){//先序遍历
			callback(this);
			this.left&&this.left.fTravelTree(callback);
			this.right&&this.right.fTravelTree(callback);
		},
		mTravelTree:function(callback){//中序遍历
			this.left&&this.left.mTravelTree(callback);
			callback(this);
			this.right&&this.right.mTravelTree(callback);
		},
		lTravelTree:function(callback){//后序遍历
			this.left&&this.left.lTravelTree(callback);
			this.right&&this.right.lTravelTree(callback);
			callback(this);
		},
		mThreadTreeCreate:function(prevNode){
			//先左子树遍历，寻找起始点
			this.left&&this.left.mThreadTreeCreate(prevNode);
			//如果left为空，则说明该节点可以放“线索”
			this.leftThread=this.left?false:true;
			//如果right为空，则说明该节点可以放“线索”
			this.rightThread=this.right?false:true;
			if(prevNode){
				if(this.leftThread){
					this.left=prevNode;
				}
				if(prevNode.rightThread){
					prevNode.right=this;
				}
			}
			prevNode=this;
			this.right&&this.right.mThreadTreeCreate(prevNode);
		},
		mThreadPrev:function(){
			if(this.leftThread){
				return this.left;
			} else {
				var leftNode=this.left;
				while (leftNode&&!leftNode.rightThread) {
					leftNode=leftNode.right;
				}
				return leftNode;
			}
		},
		mThreadNext:function(){
			if(this.rightThread){
				return this.right;
			} else {
				var rightNode=this.right;
				while (rightNode&&!rightNode.leftThread) {
					rightNode=rightNode.left;
				}
				return rightNode;
			}
		}
	};



	//使用canvas画出二叉树
	function drawTree(tree){
		var list={},
			draw=canvasDraw(),
			top=0,left=0,
			parentNode=null,
			parentLeft=0,
			parentTop=0,
			isLeft=true,
			gap=100,r=25,
			isLR=0;//0根，1左，2右，3中间
		//先序遍历
		tree.fTravelTree(function(node){
			console.log(node);
			top=node.level*100+50;
			if(!node.level){
				isLR=0;
				left=canvas.width/2;
			} else {
				parentNode=list[''+node.parent.key];
				parentLeft=parentNode.left;
				parentTop=parentNode.top;
				isLeft=node.parent.left&&(node.parent.key>node.key?true:false);
				if(!parentNode.isLR){
					isLR=isLeft?1:2;
				} else if(parentNode.isLR==1){
					isLR=isLeft?1:3;
				} else if(parentNode.isLR==2){
					isLR=!isLeft?2:3;
				} else {
					isLR=3;
				}
				gap=isLR==3?(10-node.level)*6:150;
				left=isLeft?parentLeft-gap:parentLeft+gap;
				var a=Math.abs(left-parentLeft),
					b=Math.abs(top-parentTop),
					c=Math.sqrt(a*a+b*b),
					cy=b/c*r,cx=a/c*r,
					x1=isLeft?parentLeft-cx:parentLeft+cx,
					y1=parentTop+cy,
					x2=isLeft?left+cx:left-cx,
					y2=top-cy;

				draw.line(x1,y1,x2,y2);
			}
			draw.round(left,top,r,node.key);
			list[''+node.key]={
				node:node,
				top:top,
				left:left,
				isLR:isLR
			};
		});
	}

	function canvasDraw(){
		var	canvas=document.getElementById('canvas'),
			ctx=canvas.getContext('2d');

		ctx.font='28px Palatino';
		ctx.fillStyle='#2e6da4';
		ctx.textAlign="center";
		ctx.textBaseline='middle';

		//画线
		function line(x1,y1,x2,y2){
			ctx.strokeStyle='#d43f3a';
			ctx.lineWidth=1;
			ctx.beginPath();
			ctx.moveTo(x1,y1);
			ctx.lineTo(x2,y2);
			ctx.stroke();
		}

		//画圆
		function round(x,y,r,txt){
			ctx.strokeStyle='#337ab7';
			ctx.lineWidth=2;
			ctx.beginPath();
			ctx.arc(x,y,r,0,Math.PI*2,false);
			ctx.fillText(txt,x,y);
			ctx.stroke();
		}

		return {
			line:line,
			round:round
		};
	}


	// var tree=new BTree([4,1,6,9,3,2,5,0,8,7,10]);
	var tree=new BTree([5,1,6,9,3,2,4,0,8,7,10,5.5,5.2,5.6,9.5,8.5,5.7]);
	drawTree(tree);
	tree.mThreadPrev();
	console.log(tree.mThreadPrev())
	// console.log(tree.search(15));
	// console.log(tree.delete(2));
	// console.log(tree.insert(1.5));
	// console.log(tree.insert(2.5));
</script>
</body>
</html>