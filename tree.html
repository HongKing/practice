<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>btree</title>
	<style>
		html,body{
			height: 100%;
		}
		body{
			font:14px Helvetica,Arial,"Microsoft Yahei",sans-serif;
		}
		.wrap{
			position: relative;
			width: 100%;
			height: 100%;
		}
		.node{
			position: absolute;
			width: 50px;
			height: 50px;
			border: 1px solid  #aaa;
			border-radius:50%;
			color: #555;
			font-size:30px;
			text-align:center;
			line-height: 50px;
		}
	</style>
</head>
<body>
<div class="wrap"></div>
<script>
	//二叉树	
	function BTree(list,parent){
		this.key=list[0];//值
		this.parent=parent||null;//父节点
		this.left=null;//左节点
		this.right=null;//右节点
		this.level=parent?parent.level+1:0;//树的深度
		for(var i=1,len=list.length;i<len;i++){
			this.insert(list[i]);
		}
	}

	BTree.prototype={
		insert:function(key){//插入
			if(this.key>key){
				if(!this.left){
					return this.left=new BTree([key],this);
				} else {
					return this.left.insert(key);
				}
			} else {
				if(!this.right){
					return this.right=new BTree([key],this);
				} else {
					return this.right.insert(key);
				}
			}
		},
		delete:function(key){//删除
			if(this.key==key){
				if(this.left&&this.right){
					var node=this.right;
					while (node.left) {//找到最左的节点
						node=node.left;
					}
					if(this.key==node.parent.key){//没有左节点的情况，直接将右子树上移
						this.key=node.key;
						this.right=node.right;
					} else {//有左节点的情况
						this.key=node.key;
						if(node.right){//如果还存在右节点，将右节点上移
							node.right.parent=node.parent;
							node=node.right;
						} else {//直接将该节点清除
							node.parent.left=null;
						}
					}
				} else {
					var prop=this.parent.left.key==this.key?'left':'right';
					if(this.left) {//只有左子树
						this.left.parent=this.parent;
						this.parent[prop]=this.left;
					} else if(this.right){//只有右子树
						this.right.parent=this.parent;
						this.parent[prop]=this.right;
					} else {//叶子节点
						this.parent[prop]=null;
					}
				}
				return this;			
			} else if(this.key>key){
				return this.left?this.left.delete(key):null;
			} else {
				return this.right?this.right.delete(key):null;
			}

		},
		search:function(key){//搜索
			if(this.key==key){
				return this;
			} else if(this.key>key){
				return this.left?this.left.search(key):null;
			} else {
				return this.right?this.right.search(key):null;
			}
		},
		lTravelTree:function(callback){//先序遍历
			callback(this);
			this.left&&this.left.lTravelTree(callback);
			this.right&&this.right.lTravelTree(callback);
		},
		mTravelTree:function(callback){//中序遍历
			this.left&&this.left.mTravelTree(callback);
			callback(this);
			this.right&&this.right.mTravelTree(callback);
		},
		rTravelTree:function(callback){//后序遍历
			this.left&&this.left.rTravelTree(callback);
			this.right&&this.right.rTravelTree(callback);
			callback(this);
		}
	};
	var list={};
	var wrap=document.getElementsByClassName('wrap')[0];
	var wrapWidth=wrap.offsetWidth;
	var nodeElem=null;
	function drawTree(node){
		console.log(node);
		
		nodeElem=document.createElement('div');
		nodeElem.innerHTML=node.key;
		nodeElem.className='node';
		nodeElem.setAttribute('key',node.key);
		wrap.appendChild(nodeElem);
		nodeElem.style.top=node.level*100+20+'px';
		if(!node.level){
			nodeElem.style.left=(wrapWidth/2-nodeElem.offsetWidth/2)+'px';
		} else {
			var parentLeft=parseFloat(list[''+node.parent.key].style.left,10);
			var isLeft=node.parent.left&&(node.parent.left.key==node.key?true:false);
			var gap=100;
			nodeElem.style.left=(isLeft?(parentLeft-gap):(parentLeft+gap))+'px';
		}
		list[''+node.key]=nodeElem;
	}
	var b=new BTree([4,1,6,7,3,2,5,0,8]);
	console.log(b);
	// console.log(b.search(15));
	// console.log(b.delete(2));
	b.lTravelTree(drawTree);
	// console.log(b.insert(1.5));
	// console.log(b.insert(2.5));
</script>
</body>
</html>