<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>btree</title>
	<style>

	</style>
</head>
<body>

<script>
	//二叉树	
	function BTree(list,parent){
		this.key=list[0];//值
		this.parent=parent||null;//父节点
		this.left=null;//左节点
		this.right=null;//右节点
		this.level=parent?parent.level+1:0;//树的深度
		for(var i=1,len=list.length;i<len;i++){
			this.insert(list[i]);
		}
	}

	BTree.prototype={
		insert:function(key){//插入
			if(this.key>key){
				if(!this.left){
					return this.left=new BTree([key],this);
				} else {
					return this.left.insert(key);
				}
			} else {
				if(!this.right){
					return this.right=new BTree([key],this);
				} else {
					return this.right.insert(key);
				}
			}
		},
		delete:function(key){//删除
			if(this.key==key){
				if(this.left&&this.right){
					var node=this.right;
					while (node.left) {//找到最左的节点
						node=node.left;
					}
					if(this.key==node.parent.key){//没有左节点的情况，直接将右子树上移
						this.key=node.key;
						this.right=node.right;
					} else {//有左节点的情况
						this.key=node.key;
						if(node.right){//如果还存在右节点，将右节点上移
							node.right.parent=node.parent;
							node=node.right;
						} else {//直接将该节点清除
							node.parent.left=null;
						}
					}
				} else {
					var prop=this.parent.left.key==this.key?'left':'right';
					if(this.left) {//只有左子树
						this.left.parent=this.parent;
						this.parent[prop]=this.left;
					} else if(this.right){//只有右子树
						this.right.parent=this.parent;
						this.parent[prop]=this.right;
					} else {//叶子节点
						this.parent[prop]=null;
					}
				}
				return this;			
			} else if(this.key>key){
				return this.left?this.left.delete(key):null;
			} else {
				return this.right?this.right.delete(key):null;
			}

		},
		search:function(key){//搜索
			if(this.key==key){
				return this;
			} else if(this.key>key){
				return this.left?this.left.search(key):null;
			} else {
				return this.right?this.right.search(key):null;
			}
		},
		lTravelTree:function(callback){//先序遍历
			callback(this);
			this.left&&this.left.lTravelTree(callback);
			this.right&&this.right.lTravelTree(callback);
		},
		mTravelTree:function(callback){//中序遍历
			this.left&&this.left.mTravelTree(callback);
			callback(this);
			this.right&&this.right.mTravelTree(callback);
		},
		rTravelTree:function(callback){//后序遍历
			this.left&&this.left.rTravelTree(callback);
			this.right&&this.right.rTravelTree(callback);
			callback(this);
		}
	};
	function drawTree(node){
		console.log(node);
	}
	var b=new BTree([4,1,6,7,3,2,5,0,8]);
	console.log(b);
	// console.log(b.search(15));
	// console.log(b.delete(2));
	b.lTravelTree(drawTree);
	// console.log(b.insert(1.5));
	// console.log(b.insert(2.5));
</script>
</body>
</html>