<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>btree</title>
	<style>
		html,body{
			height: 100%;
		}
		body{
			font:14px Helvetica,Arial,"Microsoft Yahei",sans-serif;
		}
		.wrap{
			position: relative;
			width: 100%;
			height: 100%;
		}
		.node{
			position: absolute;
			width: 50px;
			height: 50px;
			border: 1px solid  #aaa;
			border-radius:50%;
			color: #555;
			font-size:30px;
			text-align:center;
			line-height: 50px;
		}
		.line{
			position: absolute;
			height: 0;
			border-top: 1px solid  #aaa;
			transform-origin: 0 0;
		}
	</style>
</head>
<body>
<canvas id="canvas" width="1000" height="750"></canvas>
<!-- <div class="wrap"></div> -->
<script>
	//二叉树	
	function BTree(list,parent){
		this.key=list[0];//值
		this.parent=parent||null;//父节点
		this.left=null;//左节点
		this.right=null;//右节点
		this.level=parent?parent.level+1:0;//树的深度
		for(var i=1,len=list.length;i<len;i++){
			this.insert(list[i]);
		}
	}

	BTree.prototype={
		insert:function(key){//插入
			if(this.key>key){
				if(!this.left){
					return this.left=new BTree([key],this);
				} else {
					return this.left.insert(key);
				}
			} else {
				if(!this.right){
					return this.right=new BTree([key],this);
				} else {
					return this.right.insert(key);
				}
			}
		},
		delete:function(key){//删除
			if(this.key==key){
				if(this.left&&this.right){
					var node=this.right;
					while (node.left) {//找到最左的节点
						node=node.left;
					}
					if(this.key==node.parent.key){//没有左节点的情况，直接将右子树上移
						this.key=node.key;
						this.right=node.right;
					} else {//有左节点的情况
						this.key=node.key;
						if(node.right){//如果还存在右节点，将右节点上移
							node.right.parent=node.parent;
							node=node.right;
						} else {//直接将该节点清除
							node.parent.left=null;
						}
					}
				} else {
					var prop=this.parent.key>this.key?'left':'right';
					if(this.left) {//只有左子树
						this.left.parent=this.parent;
						this.parent[prop]=this.left;
					} else if(this.right){//只有右子树
						this.right.parent=this.parent;
						this.parent[prop]=this.right;
					} else {//叶子节点
						this.parent[prop]=null;
					}
				}
				return this;			
			} else if(this.key>key){
				return this.left?this.left.delete(key):null;
			} else {
				return this.right?this.right.delete(key):null;
			}

		},
		search:function(key){//搜索
			if(this.key==key){
				return this;
			} else if(this.key>key){
				return this.left?this.left.search(key):null;
			} else {
				return this.right?this.right.search(key):null;
			}
		},
		fTravelTree:function(callback){//先序遍历
			callback(this);
			this.left&&this.left.fTravelTree(callback);
			this.right&&this.right.fTravelTree(callback);
		},
		mTravelTree:function(callback){//中序遍历
			this.left&&this.left.mTravelTree(callback);
			callback(this);
			this.right&&this.right.mTravelTree(callback);
		},
		lTravelTree:function(callback){//后序遍历
			this.left&&this.left.lTravelTree(callback);
			this.right&&this.right.lTravelTree(callback);
			callback(this);
		}
	};

	var list={};
	// var wrap=document.getElementsByClassName('wrap')[0];
	// var wrapWidth=wrap.offsetWidth;
	var canvas=document.getElementById('canvas'),
		ctx=canvas.getContext('2d');

	function drawTree(node){
		console.log(node);
		var top=0,left=0,
			parentNode=null,
			parentLeft=0,
			isLeft=true,
			gap=100,
			nodeElem=null,
			lineElem=null,
			isLR=0;//0根，1左，2右，3中间

		// nodeElem=document.createElement('div');
		// nodeElem.innerHTML=node.key;
		// nodeElem.className='node';
		// nodeElem.setAttribute('key',node.key);
		// wrap.appendChild(nodeElem);
		top=node.level*100+20;
		// nodeElem.style.top=top+'px';
		if(!node.level){
			isLR=0;
			left=canvas.width/2;
			// nodeElem.style.left=left+'px';
		} else {
			parentNode=list[''+node.parent.key];
			parentLeft=parentNode.left;
			isLeft=node.parent.left&&(node.parent.key>node.key?true:false);
			if(!parentNode.isLR){
				isLR=isLeft?1:2;
			} else if(parentNode.isLR==1){
				isLR=isLeft?1:3;
			} else if(parentNode.isLR==2){
				isLR=!isLeft?2:3;
			} else {
				isLR=3;
			}
			gap=isLR==3?50:150;
			left=isLeft?parentLeft-gap:parentLeft+gap;
			lineTo(parentNode.left,parentNode.top,left,top,isLeft);
			// nodeElem.style.left=left+'px';
			// var x=Math.abs(left-parentNode.left);
			// var y=Math.abs(top-parentNode.top);
			// var c=Math.sqrt(x*x+y*y);
			// var angle=Math.tan(y/x)*180/Math.PI;// 弧度=角度*PI/180
			// console.log(angle);
			// lineElem=document.createElement('div');
			// lineElem.className="line";
			// lineElem.style.width=c+'px';
			// if(isLeft){
			// 	lineElem.style.transform='translate3d('+(parentNode.left)+'px,'+(parentNode.top)+'px,0) rotate('+(180-angle)+'deg)';
			// } else {
			// 	lineElem.style.transform='translate3d('+(parentNode.left+25)+'px,'+(parentNode.top+25)+'px,0) rotate('+(angle)+'deg)';
			// }
			// wrap.appendChild(lineElem);
		}
		drawRound(left,top,25,node.key);
		list[''+node.key]={
			node:node,
			// elem:nodeElem,
			top:top,
			left:left,
			isLR:isLR
		};
	}

	//画线
	function lineTo(x1,y1,x2,y2,isLeft){
		ctx.strokeStyle='#d43f3a';
		ctx.lineWidth=1.5;
		ctx.beginPath();
		var r=25;
		var x=Math.abs(x2-x1);
		var y=Math.abs(y2-y1);
		var c=Math.sqrt(x*x+y*y);
		var cy=Math.sin(y/c)*r;
		var cx=Math.cos(x/c)*r;
		if(isLeft){
			ctx.moveTo(x1-cx,y1+cy);
			ctx.lineTo(x2+cx,y2-cy);
		} else {
			ctx.moveTo(x1+cx,y1+cy);
			ctx.lineTo(x2-cx,y2-cy);
		}

		ctx.stroke();
	}

	//画圆
	function drawRound(x,y,r,txt){
		ctx.font='28px Palatino';
		ctx.fillStyle='#2e6da4';
		ctx.textAlign="center";
		ctx.textBaseline='middle';
		ctx.lineWidth=2;
		ctx.strokeStyle='#337ab7';
		ctx.beginPath();
		ctx.arc(x,y,r,0,Math.PI*2,false);
		ctx.fillText(txt,x,y);
		ctx.stroke();
	}

	// var b=new BTree([4,1,6,9,3,2,5,0,8,7,10]);
	var b=new BTree([5,1,6,9,3,2,4,0,8,7,10]);
	console.log(b);
	// console.log(b.search(15));
	// console.log(b.delete(2));
	b.fTravelTree(drawTree);
	// console.log(b.insert(1.5));
	// console.log(b.insert(2.5));
</script>
</body>
</html>